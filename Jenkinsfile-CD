@Library('Shared-lib') _
// Minimal CD pipeline: assumes images already built & pushed by CI.
// Goals: install kind/kubectl if missing (in Jenkins container), create ephemeral cluster, deploy manifests, wait for readiness.
pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '15'))
    timeout(time: 20, unit: 'MINUTES')
  }

  parameters {
    string(name: 'BACKEND_DOCKERTAG', defaultValue: 'latest', description: 'Tag shared by all service images (auth/product/order/api-gateway)')
  }

  environment {
    // Directory inside Jenkins container where we place CLI binaries if needed
    BIN_DIR = "${WORKSPACE}/.bin"
    PATH = "${BIN_DIR}:${env.PATH}"
    CLUSTER_NAME = 'ecommerce'
    NAMESPACE = 'ecommerce'
  }

  stages {
    stage('Checkout') {
      steps {
        script {
          code_checkout('https://github.com/RoshanTiwari07/nodejs-ecommerce-microservice-deployment.git', 'main')
        }
      }
    }

    stage('Validate Input') {
      steps {
        script {
          if(!params.BACKEND_DOCKERTAG?.trim()) {
            error 'BACKEND_DOCKERTAG must not be empty'
          }
          echo "Deploying tag: ${params.BACKEND_DOCKERTAG}"
        }
      }
    }

    stage('Verify Tools (Install if Missing)') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Checking for kind and kubectl..."
          
          # Check if kind exists in system PATH first
          if command -v kind >/dev/null 2>&1; then
            echo "‚úÖ Found kind in system PATH: $(which kind)"
            echo "üìã kind version: $(kind version)"
          else
            echo "‚ö†Ô∏è kind not found in system PATH, installing to workspace..."
            mkdir -p "$BIN_DIR"
            chmod 755 "$BIN_DIR"
            
            if [ -f "$BIN_DIR/kind" ]; then
              echo "‚úÖ Found kind in workspace: $BIN_DIR/kind"
            else
              echo "üì¶ Installing kind to workspace..."
              curl -fsSL https://kind.sigs.k8s.io/dl/v0.23.0/kind-linux-amd64 -o "$BIN_DIR/kind"
              chmod +x "$BIN_DIR/kind"
              echo "‚úÖ kind installed to $BIN_DIR/kind"
            fi
            export PATH="$BIN_DIR:$PATH"
          fi
          
          # Check if kubectl exists in system PATH first
          if command -v kubectl >/dev/null 2>&1; then
            echo "‚úÖ Found kubectl in system PATH: $(which kubectl)"
            echo "üìã kubectl version: $(kubectl version --client --short)"
          else
            echo "‚ö†Ô∏è kubectl not found in system PATH, installing to workspace..."
            mkdir -p "$BIN_DIR"
            chmod 755 "$BIN_DIR"
            
            if [ -f "$BIN_DIR/kubectl" ]; then
              echo "‚úÖ Found kubectl in workspace: $BIN_DIR/kubectl"
            else
              echo "üì¶ Installing kubectl to workspace..."
              KVER=$(curl -L -s https://dl.k8s.io/release/stable.txt)
              curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o "$BIN_DIR/kubectl"
              chmod +x "$BIN_DIR/kubectl"
              echo "‚úÖ kubectl installed to $BIN_DIR/kubectl"
            fi
            export PATH="$BIN_DIR:$PATH"
          fi
          
          echo "[INFO] ‚úÖ All tools are ready!"
        '''
      }
    }

    stage('Create Kind Cluster') {
      steps {
        sh '''
          set -e
          # Ensure PATH includes both system and workspace locations
          export PATH="$BIN_DIR:$PATH"
          
          echo "[INFO] Deleting any existing cluster (ignore errors)"
          kind delete cluster --name="$CLUSTER_NAME" 2>/dev/null || echo "No existing cluster to delete"
          
          echo "[INFO] Creating fresh Kind cluster: $CLUSTER_NAME"
          kind create cluster --name="$CLUSTER_NAME" --wait=90s
          
          echo "[INFO] Cluster created successfully!"
          echo "Current clusters:"
          kind get clusters
          
          echo "Cluster info:"
          kubectl cluster-info --context kind-$CLUSTER_NAME
        '''
      }
    }

    stage('Patch Image Tags in Manifests') {
      steps {
        sh '''
          set -e
          echo "[INFO] Updating deployment image tags to :${BACKEND_DOCKERTAG}"
          sed -i "s|image: roshan03ish/auth:.*|image: roshan03ish/auth:${BACKEND_DOCKERTAG}|" k8s/auth/deployment.yml
          sed -i "s|image: roshan03ish/product:.*|image: roshan03ish/product:${BACKEND_DOCKERTAG}|" k8s/product/deployment.yml
          sed -i "s|image: roshan03ish/order:.*|image: roshan03ish/order:${BACKEND_DOCKERTAG}|" k8s/order/deployment.yml
          sed -i "s|image: roshan03ish/api-gateway:.*|image: roshan03ish/api-gateway:${BACKEND_DOCKERTAG}|" k8s/api-gateway/deployment.yml
          echo "[INFO] Resulting image references:"
          grep -R "image: roshan03ish" k8s || true
        '''
      }
    }

    stage('Apply Kubernetes Manifests') {
      steps {
        sh '''
          set -e
          export PATH="$BIN_DIR:$PATH"
          
          echo "[INFO] Creating namespace (idempotent)"
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create namespace "$NAMESPACE"
          echo "‚úÖ Namespace $NAMESPACE ready"

          echo "[INFO] Applying Kubernetes manifests..."
          kubectl apply -n "$NAMESPACE" -f k8s/db || echo "‚ö†Ô∏è DB resources failed to apply"
          kubectl apply -n "$NAMESPACE" -f k8s/auth || echo "‚ö†Ô∏è Auth resources failed to apply"  
          kubectl apply -n "$NAMESPACE" -f k8s/product || echo "‚ö†Ô∏è Product resources failed to apply"
          kubectl apply -n "$NAMESPACE" -f k8s/order || echo "‚ö†Ô∏è Order resources failed to apply"
          kubectl apply -n "$NAMESPACE" -f k8s/api-gateway || echo "‚ö†Ô∏è API Gateway resources failed to apply"

          echo "[INFO] ‚úÖ All manifests applied successfully"
          echo "Resources in namespace $NAMESPACE:"
          kubectl get all -n "$NAMESPACE" || true
        '''
      }
    }

    stage('Wait for Pods') {
      steps {
        sh '''
          set -e
          export PATH="$BIN_DIR:$PATH"
          
          echo "[INFO] Waiting for deployments to be ready..."
          for app in auth product order api-gateway; do
            echo "‚è≥ Waiting for deployment/$app..."
            if kubectl rollout status deployment/$app -n "$NAMESPACE" --timeout=120s; then
              echo "‚úÖ $app deployment ready"
            else
              echo "‚ö†Ô∏è $app deployment not ready within timeout (continuing anyway)"
            fi
          done
          
          echo "[INFO] Final pod status:"
          kubectl get pods -n "$NAMESPACE" -o wide
          echo "[INFO] Service status:"
          kubectl get svc -n "$NAMESPACE"
        '''
      }
    }

    stage('Basic Service Check') {
      steps {
        sh '''
          set -e
          export PATH="$BIN_DIR:$PATH"
          
          echo "[INFO] üìã Service listing:"
          kubectl get svc -n "$NAMESPACE"
          
          echo "[INFO] üîå Testing api-gateway connectivity..."
          # Try port-forwarding to test service
          kubectl port-forward -n "$NAMESPACE" svc/api-gateway 8080:3003 >/dev/null 2>&1 &
          PF_PID=$!
          
          # Give port-forward time to establish
          sleep 10
          
          echo "[INFO] üè• Checking health endpoint..."
          if curl -fsS --max-time 10 http://127.0.0.1:8080/health >/dev/null 2>&1; then
            echo "‚úÖ Health endpoint responded successfully"
          else
            echo "‚ö†Ô∏è Health endpoint not reachable (may be expected if /health not implemented)"
          fi
          
          # Clean up port-forward
          kill $PF_PID 2>/dev/null || echo "Port-forward already terminated"
          
          echo "[INFO] ‚úÖ Service check completed"
        '''
      }
    }
  }

  post {
    success {
      echo "‚úÖ CD pipeline completed successfully for tag ${params.BACKEND_DOCKERTAG}."
    }
    failure {
      echo "‚ùå CD pipeline failed for tag ${params.BACKEND_DOCKERTAG}." 
      script {
        sh '''
          set +e
          echo "[FAILURE] Gathering diagnostics before cleanup..." || true
          export PATH="$BIN_DIR:$PATH"
          # Diagnostics (best effort)
          kubectl get ns "$NAMESPACE" 2>/dev/null && kubectl get all -n "$NAMESPACE" || true
          kubectl describe pods -n "$NAMESPACE" || true
          kubectl get events -n "$NAMESPACE" --sort-by=.lastTimestamp | tail -n 60 || true

          echo "[CLEANUP] Starting failure cleanup (namespace, PVC/PVs, cluster)"
          if command -v kubectl >/dev/null 2>&1; then
            if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
              echo "[CLEANUP] Deleting namespace $NAMESPACE (async)";
              kubectl delete namespace "$NAMESPACE" --wait=false || true
            else
              echo "[CLEANUP] Namespace $NAMESPACE not found (maybe never created)."
            fi

            echo "[CLEANUP] Checking for lingering PVs bound to namespace (rare in kind)";
            kubectl get pv --no-headers 2>/dev/null | awk '/${NAMESPACE}/ {print $1}' | while read pv; do
              [ -z "$pv" ] && continue; echo "[CLEANUP] Forcing delete of PV $pv"; kubectl delete pv "$pv" || true; done
          else
            echo "[CLEANUP] kubectl not available; skipping namespace/PV cleanup"
          fi

          # Delete the whole kind cluster (fastest way to ensure volume cleanup)
          if command -v kind >/dev/null 2>&1; then
            echo "[CLEANUP] Deleting kind cluster $CLUSTER_NAME";
            kind delete cluster --name "$CLUSTER_NAME" || true
          else
            echo "[CLEANUP] kind CLI not available; cannot delete cluster explicitly"
          fi

          echo "[CLEANUP] Failure cleanup completed." || true
        '''
      }
    }
    always {
      echo 'üèÅ Pipeline finished.'
    }
  }
}