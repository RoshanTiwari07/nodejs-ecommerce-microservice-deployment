@Library('Shared-Lib') _
// Minimal CD pipeline: assumes images already built & pushed by CI.
// Goals: install kind/kubectl if missing (in Jenkins container), create ephemeral cluster, deploy manifests, wait for readiness.
pipeline {
  agent any

  parameters {
    string(name: 'BACKEND_DOCKERTAG', defaultValue: 'latest', description: 'Tag shared by all service images (auth/product/order/api-gateway)')
  }

  environment {
    CLUSTER_NAME = 'ecommerce'
    NAMESPACE = 'ecommerce'
  }

  stages {
    stage('Checkout') {
      steps {
        script {
          code_checkout('https://github.com/RoshanTiwari07/nodejs-ecommerce-microservice-deployment.git', 'main')
        }
      }
    }

    stage('Validate Input') {
      steps {
        script {
          if(!params.BACKEND_DOCKERTAG?.trim()) {
            error 'BACKEND_DOCKERTAG must not be empty'
          }
          echo "Deploying tag: ${params.BACKEND_DOCKERTAG}"
        }
      }
    }

    stage('Verify Tools') {
      steps {
        sh '''
          echo "[INFO] Verifying required tools..."
          
          echo "‚úÖ kind version: $(kind version)"
          echo "‚úÖ kubectl version: $(kubectl version --client )"
          echo "‚úÖ docker version: $(docker --version)"
          
          echo "[INFO] All tools verified and ready!"
        '''
      }
    }

    stage('Create Multi-Node Kind Cluster') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Cleaning up any existing cluster..."
          kind delete cluster --name="$CLUSTER_NAME" 2>/dev/null || echo "No existing cluster to delete"
          
          echo "[INFO] Creating multi-node Kind cluster with load balancer..."
          kind create cluster --config=k8s/kind-config.yaml --wait=120s
          
          echo "‚úÖ Multi-node cluster created successfully!"
          echo "üìä Cluster nodes:"
          kubectl get nodes -o wide --show-labels
          
          echo "üîß Setting up load balancer (MetalLB)..."
          kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml
          kubectl wait --namespace metallb-system --for=condition=ready pod --selector=app=metallb --timeout=90s || echo "‚ö†Ô∏è MetalLB not ready yet"
          
          echo "‚öôÔ∏è Configuring load balancer IP pool..."
          cat <<EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: example
  namespace: metallb-system
spec:
  addresses:
  - 172.19.255.200-172.19.255.250
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: empty
  namespace: metallb-system
EOF

          echo "‚úÖ Load balancer configured!"
        '''
      }
    }

    stage('Connect to ArgoCD') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Connecting to existing ArgoCD instance..."
          echo "üåê ArgoCD URL: http://3.95.137.41:8081"
          
          # Install ArgoCD CLI if not present
          if ! command -v argocd >/dev/null 2>&1; then
            echo "[INFO] Installing ArgoCD CLI..."
            curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
            rm argocd-linux-amd64
          fi
          
          # Verify connection to ArgoCD server
          echo "[INFO] Testing connection to ArgoCD..."
          curl -k --connect-timeout 10 http://3.95.137.41:8081/api/version || echo "‚ö†Ô∏è ArgoCD connection test failed, continuing anyway"
          
          echo "‚úÖ ArgoCD connection configured"
          echo "üì± ArgoCD Dashboard: http://3.95.137.41:8081/applications"
        '''
      }
    }

    stage('Configure ArgoCD Integration') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Preparing ArgoCD integration files..."
          
          # Get Kind cluster info
          CLUSTER_SERVER=$(kubectl cluster-info | grep "Kubernetes control plane" | sed 's/.*https:\\/\\/\\///g' | sed 's/\\x1b\\[[0-9;]*m//g')
          echo "üìã Cluster server: https://$CLUSTER_SERVER"
          
          # Update cluster registration with actual values
          cp argocd/cluster-registration.yaml cluster-registration.yaml
          sed -i "s|name: \"\"|name: $(echo -n "kind-$CLUSTER_NAME" | base64)|g" cluster-registration.yaml
          sed -i "s|server: \"\"|server: $(echo -n "https://$CLUSTER_SERVER" | base64)|g" cluster-registration.yaml
          sed -i "s|config: \"\"|config: $(kubectl config view --raw --minify | base64 -w 0)|g" cluster-registration.yaml
          
          # Update application manifest with actual server
          cp argocd/ecommerce-app.yaml ecommerce-app.yaml
          sed -i "s|server: \"\"|server: https://$CLUSTER_SERVER|g" ecommerce-app.yaml
          
          echo "‚úÖ ArgoCD configuration files updated"
          echo "üìÅ Files ready for ArgoCD:"
          echo "   - cluster-registration.yaml (cluster config)"
          echo "   - ecommerce-app.yaml (application config)"
          echo ""
          echo "üìù To register with your ArgoCD:"
          echo "   kubectl apply -f cluster-registration.yaml -n argocd"
          echo "   kubectl apply -f ecommerce-app.yaml -n argocd"
          echo ""
          echo "üåê ArgoCD Dashboard: http://3.95.137.41:8081/applications"
        '''
      }
    }

    stage('Patch Image Tags in Manifests') {
      steps {
        sh '''
          set -e
          echo "[INFO] Updating deployment image tags to :${BACKEND_DOCKERTAG}"
          
          # Replace placeholder with actual tag in all deployment files
          find k8s -name "deployment.yml" -exec sed -i "s|{{IMAGE_TAG}}|${BACKEND_DOCKERTAG}|g" {} \\;
          
          echo "[INFO] Updated image tags:"
          grep -R "image: roshan03ish" k8s || true
        '''
      }
    }

    stage('Apply Kubernetes Manifests') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Creating namespace..."
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create namespace "$NAMESPACE"
          echo "‚úÖ Namespace $NAMESPACE ready"

          echo "[INFO] Applying manifests..."
          kubectl apply -n "$NAMESPACE" -f k8s/db
          kubectl apply -n "$NAMESPACE" -f k8s/auth
          kubectl apply -n "$NAMESPACE" -f k8s/product
          kubectl apply -n "$NAMESPACE" -f k8s/order
          kubectl apply -n "$NAMESPACE" -f k8s/api-gateway

          echo "‚úÖ All manifests applied"
        '''
      }
    }

    stage('Wait for Pods') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Waiting for deployments..."
          for app in auth product order api-gateway; do
            echo "‚è≥ Waiting for $app..."
            kubectl rollout status deployment/$app -n "$NAMESPACE" --timeout=120s
          done
          
          echo "‚úÖ All deployments ready"
          kubectl get pods -n "$NAMESPACE" -o wide
        '''
      }
    }

    stage('Service Check') {
      steps {
        sh '''
          set -e
          
          echo "[INFO] Checking services..."
          kubectl get svc -n "$NAMESPACE"
          
          echo "[INFO] Testing api-gateway..."
          kubectl port-forward -n "$NAMESPACE" svc/api-gateway 8080:3003 >/dev/null 2>&1 &
          PF_PID=$!
          sleep 8
          
          if curl -fsS --max-time 5 http://127.0.0.1:8080/health >/dev/null 2>&1; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ö†Ô∏è Health endpoint not available"
          fi
          
          kill $PF_PID 2>/dev/null || true
        '''
      }
    }
  }

  post {
    success {
      echo "‚úÖ CD pipeline completed successfully for tag ${params.BACKEND_DOCKERTAG}."
    }
    failure {
      echo "‚ùå CD pipeline failed for tag ${params.BACKEND_DOCKERTAG}." 
      script {
        sh '''
          set +e
          echo "[FAILURE] Gathering diagnostics..."
          kubectl get all -n "$NAMESPACE" || true
          kubectl describe pods -n "$NAMESPACE" || true
          kubectl get events -n "$NAMESPACE" --sort-by=.lastTimestamp | tail -n 20 || true

          echo "[CLEANUP] Cleaning up resources..."
          kubectl delete namespace "$NAMESPACE" --wait=false || true
          kind delete cluster --name "$CLUSTER_NAME" || true
          echo "‚úÖ Cleanup completed"
        '''
      }
    }
    always {
      echo 'üèÅ Pipeline finished.'
    }
  }
}